diff --git a/src/incept/utils.py b/src/incept/utils.py
index c1d55ec..7950e98 100644
--- a/src/incept/utils.py
+++ b/src/incept/utils.py
@@ -5,6 +5,8 @@ import re
 import json
 import shutil
 import jinja2
+import datetime
+import copy
 from pathlib import Path
 from platformdirs import user_documents_dir
 from typing import Optional, Any, Dict, List, Tuple
@@ -50,6 +52,30 @@ def sanitize_dir_name(name: str) -> str:
         return name.strip("_")
 
 
+# ---------------------------------------------------------------------------
+#  Video‑specific helpers
+# ---------------------------------------------------------------------------
+
+def get_video_root_path(course_path: Path) -> Path:
+    """Return the root path where the video hierarchy should be created.
+
+    Logic:
+      * If $VIDEO_IN_COURSE_FOLDER == "1" → place video files inside the text‑course
+        directory (i.e. alongside README / lesson .md files).
+      * Else fall back to $VIDEO_COURSE_FOLDER_PATH if it exists.
+      * If that is missing, use ~/Videos/courses as a safe default.
+    """
+    in_course = os.environ.get("VIDEO_IN_COURSE_FOLDER", "0") == "1"
+    if in_course:
+        return course_path
+
+    raw = os.environ.get("VIDEO_COURSE_FOLDER_PATH")
+    if raw and os.path.isdir(os.path.expandvars(raw)):
+        return Path(os.path.expandvars(raw)).expanduser()
+
+    return Path.home() / "Videos" / "courses"
+
+
 def normalize_placeholder(placeholder: str) -> str:
     """
     If a placeholder starts with "{##", remove "##" after '{'.
@@ -195,8 +221,14 @@ def create_folder_structure(
 
     # 3. Render the JSON structure from the template
     rendered_json_str = template_obj.render(**entity_data)
-    structure = json.loads(rendered_json_str)
-
+    try:
+        structure = json.loads(rendered_json_str)
+    except json.JSONDecodeError as e:
+        print("JSON error in template:",
+              f"type={template_type}, variant={template_variant}")
+        print("── rendered snippet ──")
+        print(rendered_json_str[:300])  # show first 300 chars
+        raise
     # Create the structure recursively on disk
     full_path = create_structure_recursive(structure, entity_data, parent_path)
     entity_data["final_path"] = str(full_path)
@@ -251,7 +283,8 @@ def create_courses(
     templates_dir: Path,
     create_folders: bool = True,
     keep_env_in_path: bool = True,
-    parent_path: Optional[Path] = None
+    parent_path: Optional[Path] = None,
+    include_video: bool = False,
 ):
     """
     Create folder structure for a list of courses.
@@ -285,40 +318,85 @@ def create_courses(
         else:
             course_dict["path"] = final_course_str
 
-        # Process chapters if present.
+        # ---------------------------------------------------------------
+        #  Optional: generate Jellyfin‑compatible *video* hierarchy
+        # ---------------------------------------------------------------
+        if include_video:
+            video_parent_path = get_video_root_path(Path(course_dict["path"]))
+            video_ctx = {
+                "numeric_prefix": prefix,                     # ← same 01 prefix
+                "course_slug": sanitize_dir_name(course_dict["name"]).lower(),
+                "course_title": course_dict["name"],
+                "description": course_dict.get("description", ""),
+                "institute": course_dict.get("institute", []),
+                "chapters": course_dict.get("chapters", []),
+                "name": course_dict["name"],
+            }
+            video_result = create_folder_structure(
+                entity_data=video_ctx,
+                template_type="course",
+                template_variant=course_dict.get("video_template", "video"),
+                templates_dir=templates_dir,
+                parent_path=video_parent_path,
+            )
+            course_dict["video_path"] = video_result["full_path"]
+
+        # ------------------------------------------------------------------
+        #  Process sub‑chapters
+        #  1) Always create the standard text hierarchy (back‑compat).
+        #  2) If include_video=True, also mirror those chapters as seasons
+        #     inside the video hierarchy.
+        # ------------------------------------------------------------------
         if "chapters" in course_dict and isinstance(course_dict["chapters"], list):
-            # Instead of hardcoding "chapters", we let create_chapters check for enable_subfolder/child_folder_name.
+            # 1) Text/markdown hierarchy (existing behaviour)
             create_chapters(
                 course_dict["chapters"],
                 templates_dir=templates_dir,
                 create_folders=create_folders,
                 keep_env_in_path=keep_env_in_path,
-                parent_path=course_dict["path"]
+                parent_path=course_dict["path"],
+                include_video=False,
             )
 
+            # 2) Optional video hierarchy (seasons/episodes)
+            if include_video:
+                # Deep‑copy so that video‑specific keys don't pollute text entries
+                video_chapters = copy.deepcopy(course_dict["chapters"])
+                create_chapters(
+                    video_chapters,
+                    templates_dir=templates_dir,
+                    create_folders=create_folders,
+                    keep_env_in_path=keep_env_in_path,
+                    parent_path=course_dict["video_path"],
+                    include_video=True,
+                )
+
 
 def create_chapters(
     chapters: List[Dict[str, Any]],
     templates_dir: Path,
     create_folders: bool = True,
     keep_env_in_path: bool = True,
-    parent_path: Optional[Path] = None
+    parent_path: Optional[Path] = None,
+    include_video: bool = False,
 ):
     """
     Create folder structure for a list of chapters.
     Then calls create_lessons for any sub-lessons present.
     """
     template_manager = TemplateManager(templates_dir=templates_dir)
+    path_key = "video_path" if include_video else "path"
     # Process parent_path as raw string.
     expanded_parent, raw_parent = expand_or_preserve_env_vars(raw_path=None, parent_path=parent_path, keep_env_in_path=keep_env_in_path)
 
     for chapter_dict in chapters:
-        raw_chapter_path = chapter_dict.get("path")
+        raw_chapter_path = chapter_dict.get(path_key)
         expanded_chapter_path, final_chapter_str = expand_or_preserve_env_vars(raw_chapter_path, raw_parent, keep_env_in_path)
         
         # Check if the chapter should be created in a child folder.
         # This uses the same logic as for lessons.
-        enable_subfolder = chapter_dict.get("enable_subfolder", True)
+        # Skip extra nesting when we are creating season folders for Jellyfin
+        enable_subfolder = False if include_video else chapter_dict.get("enable_subfolder", True)
         if enable_subfolder:
             child_folder_name = chapter_dict.get("child_folder_name") or "chapters"
             expanded_chapter_path = expanded_chapter_path / child_folder_name
@@ -331,20 +409,22 @@ def create_chapters(
                 "numeric_prefix": prefix,
                 "chapter_name": chapter_dict["name"],
                 "lessons": chapter_dict.get("lessons", []),
-                "name": chapter_dict["name"]
+                "name": chapter_dict["name"],
             }
 
+            template_used = "chapter"
+            variant_used  = "video" if include_video else chapter_dict.get("template", "default")
             result = create_folder_structure(
                 entity_data=context,
-                template_type="chapter",
-                template_variant=chapter_dict.get("template", "default"),
+                template_type=template_used,
+                template_variant=variant_used,
                 templates_dir=templates_dir,
-                parent_path=expanded_chapter_path
+                parent_path=expanded_chapter_path,
             )
             final_disk_path = Path(result["full_path"])
-            chapter_dict["path"] = str(Path(final_chapter_str) / final_disk_path.name)
+            chapter_dict[path_key] = str(Path(final_chapter_str) / final_disk_path.name)
         else:
-            chapter_dict["path"] = final_chapter_str
+            chapter_dict[path_key] = final_chapter_str
 
         # Process lessons if present.
         if "lessons" in chapter_dict:
@@ -356,7 +436,8 @@ def create_chapters(
                 templates_dir=templates_dir,
                 create_folders=create_folders,
                 keep_env_in_path=keep_env_in_path,
-                parent_path=chapter_dict["path"]  # using the updated chapter path
+                parent_path=chapter_dict[path_key],
+                include_video=include_video,
             )
             chapter_dict["lessons"] = lessons
 
@@ -366,47 +447,59 @@ def create_lessons(
     templates_dir: Path,
     create_folders: bool = True,
     keep_env_in_path: bool = True,
-    parent_path: Optional[Path] = None
+    parent_path: Optional[Path] = None,
+    include_video: bool = False,
 ):
     """
     Create folder/file structure for a list of lessons.
     """
     template_manager = TemplateManager(templates_dir=templates_dir)
+    path_key = "video_path" if include_video else "path"
     expanded_parent, raw_parent = expand_or_preserve_env_vars(raw_path=None, parent_path=parent_path, keep_env_in_path=keep_env_in_path)
 
     for idx, lesson_dict in enumerate(lessons):
-        raw_lesson_path = lesson_dict.get("path")
+        raw_lesson_path = lesson_dict.get(path_key)
         expanded_lesson_path, final_lesson_str = expand_or_preserve_env_vars(raw_lesson_path, raw_parent, keep_env_in_path)
 
         if create_folders:
-            enable_subfolder = lesson_dict.get("enable_subfolder", True)
+            enable_subfolder = False if include_video else lesson_dict.get("enable_subfolder", True)
             if enable_subfolder:
                 child_folder_name = lesson_dict.get("child_folder_name") or "lessons"
                 expanded_lesson_path = expanded_lesson_path / child_folder_name
                 final_lesson_str = str(Path(final_lesson_str) / child_folder_name)
 
-            ext = f".{lesson_dict.get('ext', 'md')}"
+            ext = ".mkv" if include_video else f".{lesson_dict.get('ext', 'md')}"
             base_prefix = int(get_next_numeric_prefix(expanded_lesson_path, file_extension=ext))
             prefix = f"{base_prefix:02d}"
 
             lesson_context = {
                 "numeric_prefix": prefix,
                 "lesson_name": lesson_dict["name"],
-                "ext": lesson_dict.get("ext", "md"),
-                "name": lesson_dict["name"]
+                "name": lesson_dict["name"],
             }
 
+            if include_video:
+                lesson_context.update({
+                    "lesson_slug": sanitize_dir_name(lesson_dict["name"]).lower(),
+                    "lesson_title": lesson_dict["name"],
+                    "episode_number": prefix,
+                })
+            else:
+                lesson_context["ext"] = lesson_dict.get("ext", "md")
+
+            template_used  = "lesson"
+            variant_used   = "video" if include_video else lesson_dict.get("template", "default")
             result = create_folder_structure(
                 entity_data=lesson_context,
-                template_type="lesson",
-                template_variant=lesson_dict.get("template", "default"),
+                template_type=template_used,
+                template_variant=variant_used,
                 templates_dir=templates_dir,
-                parent_path=expanded_lesson_path
+                parent_path=expanded_lesson_path,
             )
             final_disk_path = Path(result["full_path"])
-            lesson_dict["path"] = str(Path(final_lesson_str) / final_disk_path.name)
+            lesson_dict[path_key] = str(Path(final_lesson_str) / final_disk_path.name)
         else:
-            lesson_dict["path"] = final_lesson_str
+            lesson_dict[path_key] = final_lesson_str
 
 
 if __name__ == "__main__":
@@ -636,13 +729,54 @@ if __name__ == "__main__":
         print("Courses after processing:")
         print(json.dumps(courses, indent=2))
 
+    def test_create_courses_with_video():
+        """Create BOTH text and video hierarchies for all courses in full_courses.json."""
+        payload_file = os.path.join(
+            os.path.expanduser("~"),
+            ".incept",
+            "payload",
+            "full_courses.json",
+        )
+        if not os.path.exists(payload_file):
+            print(f"Payload file not found: {payload_file}")
+            return
+
+        with open(payload_file, "r", encoding="utf-8") as f:
+            payload_data = json.load(f)
+
+        try:
+            courses = payload_data["courses"]
+        except (KeyError, IndexError) as e:
+            print("Invalid payload structure:", e)
+            return
+
+        # Ensure a text‑course base path; leave video root to helper logic.
+        for course in courses:
+            if not course.get("path"):
+                course["path"] = os.environ.get(
+                    "COURSE_FOLDER_PATH",
+                    str(Path.home() / "Documents"),
+                )
+
+        create_courses(
+            courses,
+            templates_dir=templates_dir,
+            create_folders=True,
+            keep_env_in_path=True,
+            parent_path=None,
+            include_video=True,          # ← key difference
+        )
+
+        print("Courses after processing (text + video):")
+        print(json.dumps(courses, indent=2))
+
 
 
     # Uncomment the next line to test environment variable substitution.
     # test_substitute_env_vars()
 
     # Run the test for creating lessons.
-    test_create_lessons()
+    # test_create_lessons()
 
     # Run the test for creating chapters.
     # test_create_chapters()
@@ -650,5 +784,5 @@ if __name__ == "__main__":
     # Run the test for creating courses.
     # test_create_courses()
 
- 
-
+    # run a quick dual‑tree test
+    test_create_courses_with_video()
